"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkUWTQKD35js = require('./chunk-UWTQKD35.js');






var _chunkCGJOXW6Ijs = require('./chunk-CGJOXW6I.js');




var _chunkYUG22S6Wjs = require('./chunk-YUG22S6W.js');

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = _chunkYUG22S6Wjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node/common.ts
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
var _path = require('path');
var _utils = require('@antfu/utils');
var _vite = require('vite');
async function getIndexHtml({ clientRoot, themeRoots, addonRoots, data, userRoot }) {
  let main = await _fs.promises.readFile(_path.join.call(void 0, clientRoot, "index.html"), "utf-8");
  let head = "";
  let body = "";
  head += `<link rel="icon" href="${data.config.favicon}">`;
  const roots = _utils.uniq.call(void 0, [
    ...themeRoots,
    ...addonRoots,
    userRoot
  ]);
  for (const root of roots) {
    const path = _path.join.call(void 0, root, "index.html");
    if (!_fs.existsSync.call(void 0, path))
      continue;
    const index = await _fs.promises.readFile(path, "utf-8");
    head += `
${(_optionalChain([index, 'access', _4 => _4.match, 'call', _5 => _5(/<head>([\s\S]*?)<\/head>/im), 'optionalAccess', _6 => _6[1]]) || "").trim()}`;
    body += `
${(_optionalChain([index, 'access', _7 => _7.match, 'call', _8 => _8(/<body>([\s\S]*?)<\/body>/im), 'optionalAccess', _9 => _9[1]]) || "").trim()}`;
  }
  if (data.features.tweet)
    body += '\n<script async src="https://platform.twitter.com/widgets.js"></script>';
  if (data.config.fonts.webfonts.length && data.config.fonts.provider !== "none")
    head += `
<link rel="stylesheet" href="${_chunkCGJOXW6Ijs.generateGoogleFontsUrl.call(void 0, data.config.fonts)}" type="text/css">`;
  main = main.replace("__ENTRY__", _chunkCGJOXW6Ijs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}
async function mergeViteConfigs({ addonRoots, themeRoots }, viteConfig, config, command) {
  const configEnv = {
    mode: "development",
    command
  };
  const files = _utils.uniq.call(void 0, [
    ...themeRoots,
    ...addonRoots
  ]).map((i) => _path.join.call(void 0, i, "vite.config.ts"));
  for await (const file of files) {
    if (!_fs.existsSync.call(void 0, file))
      continue;
    const viteConfig2 = await _vite.loadConfigFromFile.call(void 0, configEnv, file);
    if (!_optionalChain([viteConfig2, 'optionalAccess', _10 => _10.config]))
      continue;
    config = _vite.mergeConfig.call(void 0, config, viteConfig2.config);
  }
  return _vite.mergeConfig.call(void 0, viteConfig, config);
}

// node/plugins/preset.ts


var _process = require('process'); var _process2 = _interopRequireDefault(_process);
var _pluginvue = require('@vitejs/plugin-vue'); var _pluginvue2 = _interopRequireDefault(_pluginvue);
var _pluginvuejsx = require('@vitejs/plugin-vue-jsx'); var _pluginvuejsx2 = _interopRequireDefault(_pluginvuejsx);
var _vite3 = require('unplugin-icons/vite'); var _vite4 = _interopRequireDefault(_vite3);
var _resolver = require('unplugin-icons/resolver'); var _resolver2 = _interopRequireDefault(_resolver);
var _vite5 = require('unplugin-vue-components/vite'); var _vite6 = _interopRequireDefault(_vite5);
var _vitepluginvueserverref = require('vite-plugin-vue-server-ref'); var _vitepluginvueserverref2 = _interopRequireDefault(_vitepluginvueserverref);


// node/drawings.ts

var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
function resolveDrawingsDir(options) {
  return options.data.config.drawings.persist ? _path.resolve.call(void 0, 
    _path.dirname.call(void 0, options.entry),
    options.data.config.drawings.persist
  ) : void 0;
}
async function loadDrawings(options) {
  const dir = resolveDrawingsDir(options);
  if (!dir || !_fsextra2.default.existsSync(dir))
    return {};
  const files = await _fastglob2.default.call(void 0, "*.svg", {
    onlyFiles: true,
    cwd: dir,
    absolute: true,
    suppressErrors: true
  });
  const obj = {};
  await Promise.all(files.map(async (path) => {
    const num = +_path.basename.call(void 0, path, ".svg");
    if (Number.isNaN(num))
      return;
    const content = await _fsextra2.default.readFile(path, "utf8");
    const lines = content.split(/\n/g);
    obj[num.toString()] = lines.slice(1, -1).join("\n");
  }));
  return obj;
}
async function writeDrawings(options, drawing) {
  const dir = resolveDrawingsDir(options);
  if (!dir)
    return;
  const width = options.data.config.canvasWidth;
  const height = Math.round(width / options.data.config.aspectRatio);
  const SVG_HEAD = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`;
  await _fsextra2.default.ensureDir(dir);
  return Promise.all(
    Object.entries(drawing).map(async ([key, value]) => {
      if (!value)
        return;
      const svg = `${SVG_HEAD}
${value}
</svg>`;
      await _fsextra2.default.writeFile(_path.join.call(void 0, dir, `${key}.svg`), svg, "utf-8");
    })
  );
}

// node/plugins/extendConfig.ts


var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault(_isinstalledglobally);


// ../client/package.json
var dependencies = {
  "@antfu/utils": "^0.7.6",
  "@slidev/parser": "workspace:*",
  "@slidev/types": "workspace:*",
  "@unocss/reset": "^0.56.5",
  "@vueuse/core": "^10.5.0",
  "@vueuse/head": "^2.0.0",
  "@vueuse/math": "^10.5.0",
  "@vueuse/motion": "^2.0.0",
  codemirror: "^5.65.5",
  defu: "^6.1.2",
  drauu: "^0.3.7",
  "file-saver": "^2.0.5",
  "fuse.js": "^6.6.2",
  "js-base64": "^3.7.5",
  "js-yaml": "^4.1.0",
  katex: "^0.16.9",
  mermaid: "^10.5.0",
  "monaco-editor": "^0.37.1",
  nanoid: "^5.0.1",
  prettier: "^3.0.3",
  recordrtc: "^5.6.2",
  resolve: "^1.22.6",
  unocss: "^0.56.5",
  "vite-plugin-windicss": "^1.9.1",
  vue: "^3.3.4",
  "vue-router": "^4.2.5",
  "vue-starport": "^0.4.0",
  windicss: "^3.5.6"
};

// node/vite/searchRoot.ts


var ROOT_FILES = [
  // '.git',
  // https://pnpm.js.org/workspaces/
  "pnpm-workspace.yaml"
  // https://rushjs.io/pages/advanced/config_files/
  // 'rush.json',
  // https://nx.dev/latest/react/getting-started/nx-setup
  // 'workspace.json',
  // 'nx.json'
];
function hasWorkspacePackageJSON(root) {
  const path = _path.join.call(void 0, root, "package.json");
  try {
    _fs2.default.accessSync(path, _fs2.default.constants.R_OK);
  } catch (e2) {
    return false;
  }
  const content = JSON.parse(_fs2.default.readFileSync(path, "utf-8")) || {};
  return !!content.workspaces;
}
function hasRootFile(root) {
  return ROOT_FILES.some((file) => _fs2.default.existsSync(_path.join.call(void 0, root, file)));
}
function hasPackageJSON(root) {
  const path = _path.join.call(void 0, root, "package.json");
  return _fs2.default.existsSync(path);
}
function searchForPackageRoot(current, root = current) {
  if (hasPackageJSON(current))
    return current;
  const dir = _path.dirname.call(void 0, current);
  if (!dir || dir === current)
    return root;
  return searchForPackageRoot(dir, root);
}
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
  if (hasRootFile(current))
    return current;
  if (hasWorkspacePackageJSON(current))
    return current;
  const dir = _path.dirname.call(void 0, current);
  if (!dir || dir === current)
    return root;
  return searchForWorkspaceRoot(dir, root);
}

// node/plugins/extendConfig.ts
var EXCLUDE = [
  "@slidev/shared",
  "@slidev/types",
  "@slidev/client",
  "@slidev/client/constants",
  "@slidev/client/logic/dark",
  "@vueuse/core",
  "@vueuse/shared",
  "@unocss/reset",
  "unocss",
  "mermaid",
  "vite-plugin-windicss",
  "vue-demi",
  "vue"
];
function createConfigPlugin(options) {
  return {
    name: "slidev:config",
    async config(config) {
      const injection = {
        define: getDefine(options),
        resolve: {
          alias: {
            "@slidev/client/": `${_chunkCGJOXW6Ijs.toAtFS.call(void 0, options.clientRoot)}/`
          },
          dedupe: ["vue"]
        },
        optimizeDeps: {
          include: [
            ...Object.keys(dependencies).filter((i) => !EXCLUDE.includes(i)),
            "codemirror/mode/javascript/javascript",
            "codemirror/mode/css/css",
            "codemirror/mode/markdown/markdown",
            "codemirror/mode/xml/xml",
            "codemirror/mode/htmlmixed/htmlmixed",
            "codemirror/addon/display/placeholder",
            "prettier/plugins/babel",
            "prettier/plugins/html",
            "prettier/plugins/typescript",
            "mermaid/dist/mermaid.esm.min.mjs",
            "mermaid/dist/mermaid.esm.mjs",
            "vite-plugin-vue-server-ref/client"
          ],
          exclude: EXCLUDE
        },
        css: options.data.config.css === "unocss" ? {
          postcss: {
            plugins: [
              await Promise.resolve().then(() => require("postcss-nested")).then((r) => (r.default || r)())
            ]
          }
        } : {},
        server: {
          fs: {
            strict: true,
            allow: _utils.uniq.call(void 0, [
              searchForWorkspaceRoot(options.userRoot),
              searchForWorkspaceRoot(options.cliRoot),
              ..._isinstalledglobally2.default ? [_path.dirname.call(void 0, _chunkCGJOXW6Ijs.resolveGlobalImportPath.call(void 0, "@slidev/client/package.json")), _path.dirname.call(void 0, _chunkCGJOXW6Ijs.resolveGlobalImportPath.call(void 0, "katex/package.json"))] : []
            ])
          }
        },
        publicDir: _path.join.call(void 0, options.userRoot, "public")
      };
      if (_isinstalledglobally2.default) {
        injection.cacheDir = _path.join.call(void 0, options.cliRoot, "node_modules/.vite");
        injection.root = options.cliRoot;
        injection.resolve.alias.vue = `${_chunkCGJOXW6Ijs.resolveImportPath.call(void 0, "vue/dist/vue.esm-browser.js", true)}`;
      }
      return _vite.mergeConfig.call(void 0, injection, config);
    },
    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url.endsWith(".html")) {
            res.setHeader("Content-Type", "text/html");
            res.statusCode = 200;
            res.end(await getIndexHtml(options));
            return;
          }
          next();
        });
      };
    }
  };
}
function getDefine(options) {
  return {
    __DEV__: options.mode === "dev" ? "true" : "false",
    __SLIDEV_CLIENT_ROOT__: JSON.stringify(_chunkCGJOXW6Ijs.toAtFS.call(void 0, options.clientRoot)),
    __SLIDEV_HASH_ROUTE__: JSON.stringify(options.data.config.routerMode === "hash"),
    __SLIDEV_FEATURE_DRAWINGS__: JSON.stringify(options.data.config.drawings.enabled === true || options.data.config.drawings.enabled === options.mode),
    __SLIDEV_FEATURE_EDITOR__: JSON.stringify(options.mode === "dev" && options.data.config.editor !== false),
    __SLIDEV_FEATURE_DRAWINGS_PERSIST__: JSON.stringify(!!options.data.config.drawings.persist === true),
    __SLIDEV_FEATURE_RECORD__: JSON.stringify(options.data.config.record === true || options.data.config.record === options.mode),
    __SLIDEV_FEATURE_PRESENTER__: JSON.stringify(options.data.config.presenter === true || options.data.config.presenter === options.mode),
    __SLIDEV_HAS_SERVER__: options.mode !== "build" ? "true" : "false"
  };
}

// node/plugins/loaders.ts
var import_fast_deep_equal = _chunkYUG22S6Wjs.__toESM.call(void 0, require_fast_deep_equal());





var _markdownit = require('markdown-it'); var _markdownit2 = _interopRequireDefault(_markdownit);
var _kolorist = require('kolorist');
var _markdownitlinkattributes = require('markdown-it-link-attributes'); var _markdownitlinkattributes2 = _interopRequireDefault(_markdownitlinkattributes);
var _fs3 = require('@slidev/parser/fs'); var parser = _interopRequireWildcard(_fs3);
var regexId = /^\/\@slidev\/slide\/(\d+)\.(md|json)(?:\?import)?$/;
var regexIdQuery = /(\d+?)\.(md|json|frontmatter)$/;
var vueContextImports = [
  'import { inject as _vueInject, provide as _vueProvide, toRef as _vueToRef } from "vue"',
  `import {
    injectionSlidevContext as _injectionSlidevContext, 
    injectionClicks as _injectionClicks,
    injectionCurrentPage as _injectionCurrentPage,
    injectionRenderContext as _injectionRenderContext,
    injectionFrontmatter as _injectionFrontmatter,
  } from "@slidev/client/constants.ts"`.replace(/\n\s+/g, "\n"),
  "const $slidev = _vueInject(_injectionSlidevContext)",
  'const $nav = _vueToRef($slidev, "nav")',
  "const $clicks = _vueInject(_injectionClicks)",
  "const $page = _vueInject(_injectionCurrentPage)",
  "const $renderContext = _vueInject(_injectionRenderContext)"
];
function getBodyJson(req) {
  return new Promise((resolve3, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve3(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
var md = _markdownit2.default.call(void 0, { html: true });
md.use(_markdownitlinkattributes2.default, {
  attrs: {
    target: "_blank",
    rel: "noopener"
  }
});
function prepareSlideInfo(data) {
  return {
    ...data,
    noteHTML: md.render(_optionalChain([data, 'optionalAccess', _11 => _11.note]) || "")
  };
}
function createSlidesLoader({ data, entry, clientRoot, themeRoots, addonRoots, userRoot, roots, remote, mode }, pluginOptions, serverOptions) {
  const slidePrefix = "/@slidev/slides/";
  const hmrPages = /* @__PURE__ */ new Set();
  let server;
  let _layouts_cache_time = 0;
  let _layouts_cache = {};
  return [
    {
      name: "slidev:loader",
      configureServer(_server) {
        server = _server;
        updateServerWatcher();
        server.middlewares.use(async (req, res, next) => {
          const match = _optionalChain([req, 'access', _12 => _12.url, 'optionalAccess', _13 => _13.match, 'call', _14 => _14(regexId)]);
          if (!match)
            return next();
          const [, no, type] = match;
          const idx = Number.parseInt(no);
          if (type === "json" && req.method === "GET") {
            res.write(JSON.stringify(prepareSlideInfo(data.slides[idx])));
            return res.end();
          }
          if (type === "json" && req.method === "POST") {
            const body = await getBodyJson(req);
            const slide = data.slides[idx];
            hmrPages.add(idx);
            if (slide.source) {
              Object.assign(slide.source, body);
              await parser.saveExternalSlide(slide.source);
            } else {
              Object.assign(slide, body);
              await parser.save(data, entry);
            }
            res.statusCode = 200;
            res.write(JSON.stringify(prepareSlideInfo(slide)));
            return res.end();
          }
          next();
        });
      },
      async handleHotUpdate(ctx) {
        if (!data.entries.some((i) => _utils.slash.call(void 0, i) === ctx.file))
          return;
        await ctx.read();
        const newData = await parser.load(entry, data.themeMeta);
        const moduleIds = /* @__PURE__ */ new Set();
        if (data.slides.length !== newData.slides.length) {
          moduleIds.add("/@slidev/routes");
          _utils.range.call(void 0, newData.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.headmatter.defaults, newData.headmatter.defaults)) {
          moduleIds.add("/@slidev/routes");
          _utils.range.call(void 0, data.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.config, newData.config))
          moduleIds.add("/@slidev/configs");
        if (!(0, import_fast_deep_equal.default)(data.features, newData.features)) {
          setTimeout(() => {
            ctx.server.ws.send({ type: "full-reload" });
          }, 1);
        }
        const length = Math.max(data.slides.length, newData.slides.length);
        for (let i = 0; i < length; i++) {
          const a = data.slides[i];
          const b = newData.slides[i];
          if (_optionalChain([a, 'optionalAccess', _15 => _15.content, 'access', _16 => _16.trim, 'call', _17 => _17()]) === _optionalChain([b, 'optionalAccess', _18 => _18.content, 'access', _19 => _19.trim, 'call', _20 => _20()]) && _optionalChain([a, 'optionalAccess', _21 => _21.title, 'optionalAccess', _22 => _22.trim, 'call', _23 => _23()]) === _optionalChain([b, 'optionalAccess', _24 => _24.title, 'optionalAccess', _25 => _25.trim, 'call', _26 => _26()]) && _optionalChain([a, 'optionalAccess', _27 => _27.note]) === _optionalChain([b, 'optionalAccess', _28 => _28.note]) && (0, import_fast_deep_equal.default)(a.frontmatter, b.frontmatter))
            continue;
          ctx.server.ws.send({
            type: "custom",
            event: "slidev-update",
            data: {
              id: i,
              data: prepareSlideInfo(newData.slides[i])
            }
          });
          hmrPages.add(i);
        }
        _optionalChain([serverOptions, 'access', _29 => _29.onDataReload, 'optionalCall', _30 => _30(newData, data)]);
        Object.assign(data, newData);
        if (hmrPages.size > 0)
          moduleIds.add("/@slidev/titles.md");
        const vueModules = Array.from(hmrPages).flatMap((i) => [
          ctx.server.moduleGraph.getModuleById(`${slidePrefix}${i + 1}.frontmatter`),
          ctx.server.moduleGraph.getModuleById(`${slidePrefix}${i + 1}.md`)
        ]);
        hmrPages.clear();
        const moduleEntries = [
          ...vueModules,
          ...Array.from(moduleIds).map((id) => ctx.server.moduleGraph.getModuleById(id))
        ].filter(_utils.notNullish).filter((i) => !_optionalChain([i, 'access', _31 => _31.id, 'optionalAccess', _32 => _32.startsWith, 'call', _33 => _33("/@id/@vite-icons")]));
        updateServerWatcher();
        return moduleEntries;
      },
      resolveId(id) {
        if (id.startsWith(slidePrefix) || id.startsWith("/@slidev/"))
          return id;
        return null;
      },
      load(id) {
        if (id === "/@slidev/routes")
          return generateRoutes();
        if (id === "/@slidev/layouts")
          return generateLayouts();
        if (id === "/@slidev/styles")
          return generateUserStyles();
        if (id === "/@slidev/monaco-types")
          return generateMonacoTypes();
        if (id === "/@slidev/configs")
          return generateConfigs();
        if (id === "/@slidev/global-components/top")
          return generateGlobalComponents("top");
        if (id === "/@slidev/global-components/bottom")
          return generateGlobalComponents("bottom");
        if (id === "/@slidev/custom-nav-controls")
          return generateCustomNavControls();
        if (id === "/@slidev/titles.md") {
          return {
            code: data.slides.filter(({ frontmatter }) => !_optionalChain([frontmatter, 'optionalAccess', _34 => _34.disabled])).map(({ title }, i) => `<template ${i === 0 ? "v-if" : "v-else-if"}="+no === ${i + 1}">

${title}

</template>`).join(""),
            map: { mappings: "" }
          };
        }
        if (id.startsWith(slidePrefix)) {
          const remaning = id.slice(slidePrefix.length);
          const match = remaning.match(regexIdQuery);
          if (match) {
            const [, no, type] = match;
            const pageNo = Number.parseInt(no) - 1;
            const slide = data.slides[pageNo];
            if (!slide)
              return;
            if (type === "md") {
              return {
                code: _optionalChain([slide, 'optionalAccess', _35 => _35.content]),
                map: { mappings: "" }
              };
            } else if (type === "frontmatter") {
              return {
                code: [
                  "// @unocss-include",
                  'import { reactive, computed } from "vue"',
                  `export const frontmatter = reactive(${JSON.stringify(slide.frontmatter)})`,
                  `export const meta = reactive({
                    layout: computed(() => frontmatter.layout),
                    transition: computed(() => frontmatter.transition),
                    class: computed(() => frontmatter.class),
                    clicks: computed(() => frontmatter.clicks),
                    name: computed(() => frontmatter.name),
                    slide: {
                      ...(${JSON.stringify({
                    ...prepareSlideInfo(slide),
                    frontmatter: void 0,
                    // remove raw content in build, optimize the bundle size
                    ...mode === "build" ? { raw: "", content: "", note: "" } : {}
                  })}),
                      frontmatter,
                      filepath: ${JSON.stringify(_optionalChain([slide, 'access', _36 => _36.source, 'optionalAccess', _37 => _37.filepath]) || entry)},
                      id: ${pageNo},
                      no: ${no},
                    },
                    __clicksElements: [],
                    __preloaded: false,
                  })`,
                  "export default frontmatter",
                  // handle HMR, update frontmatter with update
                  "if (import.meta.hot) {",
                  "  import.meta.hot.accept(({ frontmatter: update }) => {",
                  "    if(!update) return",
                  "    Object.keys(frontmatter).forEach(key => {",
                  "      if (!(key in update)) delete frontmatter[key]",
                  "    })",
                  "    Object.assign(frontmatter, update)",
                  "  })",
                  "}"
                ].join("\n"),
                map: { mappings: "" }
              };
            }
          }
          return {
            code: "",
            map: { mappings: "" }
          };
        }
      }
    },
    {
      name: "slidev:layout-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.startsWith(slidePrefix))
          return;
        const remaning = id.slice(slidePrefix.length);
        const match = remaning.match(regexIdQuery);
        if (!match)
          return;
        const [, no, type] = match;
        if (type !== "md")
          return;
        const pageNo = Number.parseInt(no) - 1;
        return transformMarkdown(code, pageNo, data);
      }
    },
    {
      name: "slidev:context-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.endsWith(".vue") || id.includes("/@slidev/client/") || id.includes("/packages/client/"))
          return;
        return transformVue(code);
      }
    },
    {
      name: "slidev:title-transform:pre",
      enforce: "pre",
      transform(code, id) {
        if (id !== "/@slidev/titles.md")
          return;
        return transformTitles(code);
      }
    },
    {
      name: "slidev:slide-transform:post",
      enforce: "post",
      transform(code, id) {
        if (!id.match(/\/@slidev\/slides\/\d+\.md($|\?)/))
          return;
        const replaced = code.replace("if (_rerender_only)", "if (false)");
        if (replaced !== code)
          return replaced;
      }
    }
  ];
  function updateServerWatcher() {
    if (!server)
      return;
    server.watcher.add(_optionalChain([data, 'access', _38 => _38.entries, 'optionalAccess', _39 => _39.map, 'call', _40 => _40(_utils.slash)]) || []);
  }
  async function transformMarkdown(code, pageNo, data2) {
    const layouts = await getLayouts();
    const frontmatter = {
      ..._optionalChain([data2, 'access', _41 => _41.headmatter, 'optionalAccess', _42 => _42.defaults]) || {},
      ..._optionalChain([data2, 'access', _43 => _43.slides, 'access', _44 => _44[pageNo], 'optionalAccess', _45 => _45.frontmatter]) || {}
    };
    let layoutName = _optionalChain([frontmatter, 'optionalAccess', _46 => _46.layout]) || (pageNo === 0 ? "cover" : "default");
    if (!layouts[layoutName]) {
      console.error(_kolorist.red.call(void 0, `
Unknown layout "${_kolorist.bold.call(void 0, layoutName)}".${_kolorist.yellow.call(void 0, " Available layouts are:")}`) + Object.keys(layouts).map((i, idx) => (idx % 3 === 0 ? "\n    " : "") + _kolorist.gray.call(void 0, i.padEnd(15, " "))).join("  "));
      console.error();
      layoutName = "default";
    }
    delete frontmatter.title;
    const imports = [
      ...vueContextImports,
      `import InjectedLayout from "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, layouts[layoutName])}"`,
      `import frontmatter from "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, `${slidePrefix + (pageNo + 1)}.frontmatter`)}"`,
      "const $frontmatter = frontmatter",
      "_vueProvide(_injectionFrontmatter, frontmatter)",
      // update frontmatter in router
      ";(() => {",
      "  const route = $slidev.nav.rawRoutes.find(i => i.path === String($page.value))",
      "  if (route?.meta?.slide?.frontmatter) {",
      "    Object.keys(route.meta.slide.frontmatter).forEach(key => {",
      "      if (!(key in $frontmatter)) delete route.meta.slide.frontmatter[key]",
      "    })",
      "    Object.assign(route.meta.slide.frontmatter, frontmatter)",
      "  }",
      "})();"
    ];
    code = code.replace(/(<script setup.*>)/g, `$1
${imports.join("\n")}
`);
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
<InjectedLayout v-bind="frontmatter">
${body}
</InjectedLayout>
${code.slice(injectB)}`;
    return code;
  }
  function transformVue(code) {
    if (code.includes("injectionSlidevContext") || code.includes("injectionClicks") || code.includes("const $slidev"))
      return code;
    const imports = [
      ...vueContextImports,
      "const $frontmatter = _vueInject(_injectionFrontmatter)"
    ];
    const matchScript = code.match(/<script((?!setup).)*(setup)?.*>/);
    if (matchScript && matchScript[2]) {
      return code.replace(/(<script.*>)/g, `$1
${imports.join("\n")}
`);
    } else if (matchScript && !matchScript[2]) {
      const matchExport = code.match(/export\s+default\s+{/);
      if (matchExport) {
        const exportIndex = (matchExport.index || 0) + matchExport[0].length;
        let component = code.slice(exportIndex);
        component = component.slice(0, component.indexOf("</script>"));
        const scriptIndex = (matchScript.index || 0) + matchScript[0].length;
        const provideImport = '\nimport { injectionSlidevContext } from "@slidev/client/constants.ts"\n';
        code = `${code.slice(0, scriptIndex)}${provideImport}${code.slice(scriptIndex)}`;
        let injectIndex = exportIndex + provideImport.length;
        let injectObject = "$slidev: { from: injectionSlidevContext },";
        const matchInject = component.match(/.*inject\s*:\s*([\[{])/);
        if (matchInject) {
          injectIndex += (matchInject.index || 0) + matchInject[0].length;
          if (matchInject[1] === "[") {
            let injects = component.slice((matchInject.index || 0) + matchInject[0].length);
            const injectEndIndex = injects.indexOf("]");
            injects = injects.slice(0, injectEndIndex);
            injectObject += injects.split(",").map((inject) => `${inject}: {from: ${inject}}`).join(",");
            return `${code.slice(0, injectIndex - 1)}{
${injectObject}
}${code.slice(injectIndex + injectEndIndex + 1)}`;
          } else {
            return `${code.slice(0, injectIndex)}
${injectObject}
${code.slice(injectIndex)}`;
          }
        }
        return `${code.slice(0, injectIndex)}
inject: { ${injectObject} },
${code.slice(injectIndex)}`;
      }
    }
    return `<script setup>
${imports.join("\n")}
</script>
${code}`;
  }
  function transformTitles(code) {
    return code.replace(/<template>\s*<div>\s*<p>/, "<template>").replace(/<\/p>\s*<\/div>\s*<\/template>/, "</template>").replace(/<script\ssetup>/, `<script setup lang="ts">
defineProps<{ no: number | string }>()`);
  }
  async function getLayouts() {
    const now = Date.now();
    if (now - _layouts_cache_time < 2e3)
      return _layouts_cache;
    const layouts = {};
    const roots2 = _utils.uniq.call(void 0, [
      userRoot,
      ...themeRoots,
      ...addonRoots,
      clientRoot
    ]);
    for (const root of roots2) {
      const layoutPaths = await _fastglob2.default.call(void 0, "layouts/**/*.{vue,ts}", {
        cwd: root,
        absolute: true,
        suppressErrors: true
      });
      for (const layoutPath of layoutPaths) {
        const layout = _path.basename.call(void 0, layoutPath).replace(/\.\w+$/, "");
        if (layouts[layout])
          continue;
        layouts[layout] = layoutPath;
      }
    }
    _layouts_cache_time = now;
    _layouts_cache = layouts;
    return layouts;
  }
  async function generateUserStyles() {
    const imports = [
      `import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/vars.css"))}"`,
      `import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/index.css"))}"`,
      `import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/code.css"))}"`,
      `import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/katex.css"))}"`,
      `import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/transitions.css"))}"`
    ];
    const roots2 = _utils.uniq.call(void 0, [
      ...themeRoots,
      ...addonRoots,
      userRoot
    ]);
    for (const root of roots2) {
      const styles = [
        _path.join.call(void 0, root, "styles", "index.ts"),
        _path.join.call(void 0, root, "styles", "index.js"),
        _path.join.call(void 0, root, "styles", "index.css"),
        _path.join.call(void 0, root, "styles.css"),
        _path.join.call(void 0, root, "style.css")
      ];
      for (const style of styles) {
        if (_fsextra.existsSync.call(void 0, style)) {
          imports.push(`import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, style)}"`);
          continue;
        }
      }
    }
    if (data.features.katex)
      imports.push(`import "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, _chunkCGJOXW6Ijs.resolveImportPath.call(void 0, "katex/dist/katex.min.css", true))}"`);
    if (data.config.css === "unocss") {
      imports.unshift(
        'import "@unocss/reset/tailwind.css"',
        'import "uno:preflights.css"',
        'import "uno:typography.css"',
        'import "uno:shortcuts.css"'
      );
      imports.push('import "uno.css"');
    } else {
      imports.unshift(
        'import "virtual:windi-components.css"',
        'import "virtual:windi-base.css"'
      );
      imports.push('import "virtual:windi-utilities.css"');
      if (_process2.default.env.NODE_ENV !== "production")
        imports.push('import "virtual:windi-devtools"');
    }
    return imports.join("\n");
  }
  async function generateMonacoTypes() {
    return `void 0; ${parser.scanMonacoModules(data.raw).map((i) => `import('/@slidev-monaco-types/${i}')`).join("\n")}`;
  }
  async function generateLayouts() {
    const imports = [];
    const layouts = _utils.objectMap.call(void 0, 
      await getLayouts(),
      (k, v) => {
        imports.push(`import __layout_${k} from "${_chunkCGJOXW6Ijs.toAtFS.call(void 0, v)}"`);
        return [k, `__layout_${k}`];
      }
    );
    return [
      imports.join("\n"),
      `export default {
${Object.entries(layouts).map(([k, v]) => `"${k}": ${v}`).join(",\n")}
}`
    ].join("\n\n");
  }
  async function generateRoutes() {
    const imports = [];
    const redirects = [];
    const layouts = await getLayouts();
    imports.push(`import __layout__end from '${layouts.end}'`);
    let no = 1;
    const routes = data.slides.filter(({ frontmatter }) => !_optionalChain([frontmatter, 'optionalAccess', _47 => _47.disabled])).map((i, idx) => {
      imports.push(`import n${no} from '${slidePrefix}${idx + 1}.md'`);
      imports.push(`import { meta as f${no} } from '${slidePrefix}${idx + 1}.frontmatter'`);
      const route = `{ path: '${no}', name: 'page-${no}', component: n${no}, meta: f${no} }`;
      if (_optionalChain([i, 'access', _48 => _48.frontmatter, 'optionalAccess', _49 => _49.routeAlias]))
        redirects.push(`{ path: '${_optionalChain([i, 'access', _50 => _50.frontmatter, 'optionalAccess', _51 => _51.routeAlias])}', redirect: { path: '${no}' } }`);
      no += 1;
      return route;
    });
    const routesStr = `export default [
${routes.join(",\n")}
]`;
    const redirectsStr = `export const redirects = [
${redirects.join(",\n")}
]`;
    return [...imports, routesStr, redirectsStr].join("\n");
  }
  function generateConfigs() {
    const config = { ...data.config, remote };
    if (_utils.isString.call(void 0, config.title)) {
      const tokens = md.parseInline(config.title, {});
      config.title = _chunkCGJOXW6Ijs.stringifyMarkdownTokens.call(void 0, tokens);
    }
    if (_utils.isString.call(void 0, config.info))
      config.info = md.render(config.info);
    return `export default ${JSON.stringify(config)}`;
  }
  async function generateGlobalComponents(layer) {
    const components = roots.flatMap((root) => {
      if (layer === "top") {
        return [
          _path.join.call(void 0, root, "global.vue"),
          _path.join.call(void 0, root, "global-top.vue"),
          _path.join.call(void 0, root, "GlobalTop.vue")
        ];
      } else {
        return [
          _path.join.call(void 0, root, "global-bottom.vue"),
          _path.join.call(void 0, root, "GlobalBottom.vue")
        ];
      }
    }).filter((i) => _fsextra2.default.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${_chunkCGJOXW6Ijs.toAtFS.call(void 0, i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
  async function generateCustomNavControls() {
    const components = roots.flatMap((root) => {
      return [
        _path.join.call(void 0, root, "custom-nav-controls.vue"),
        _path.join.call(void 0, root, "CustomNavControls.vue")
      ];
    }).filter((i) => _fsextra2.default.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${_chunkCGJOXW6Ijs.toAtFS.call(void 0, i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
}

// node/plugins/monacoTransform.ts



async function getPackageData(pkg) {
  const { resolvePackageData } = await eval('import("vite")');
  const info = resolvePackageData(pkg, _process2.default.cwd());
  if (!info)
    return;
  const typePath = info.data.types || info.data.typings;
  if (!typePath)
    return;
  return [info, typePath];
}
function createMonacoTypesLoader() {
  return {
    name: "slidev:monaco-types-loader",
    resolveId(id) {
      if (id.startsWith("/@slidev-monaco-types/"))
        return id;
      return null;
    },
    async load(id) {
      const match = id.match(/^\/\@slidev-monaco-types\/(.*)$/);
      if (match) {
        const pkg2 = match[1];
        const packageData = await getPackageData(pkg2) || await getPackageData(`@types/${pkg2}`);
        if (!packageData)
          return;
        const [info2, typePath2] = packageData;
        return [
          "import * as monaco from 'monaco-editor'",
          `import Type from "${_utils.slash.call(void 0, _path.join.call(void 0, info2.dir, typePath2))}?raw"`,
          ...Object.keys(info2.data.dependencies || {}).map((i) => `import "/@slidev-monaco-types/${i}"`),
          `monaco.languages.typescript.typescriptDefaults.addExtraLib(\`declare module "${pkg2}" { \${Type} }\`)`
        ].join("\n");
      }
    }
  };
}

// node/plugins/setupClient.ts



function createClientSetupPlugin({ clientRoot, themeRoots, addonRoots, userRoot }) {
  const setupEntry = _utils.slash.call(void 0, _path.resolve.call(void 0, clientRoot, "setup"));
  return {
    name: "slidev:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        let getInjections2 = function(isAwait = false, isChained = false) {
          return injections.join("\n").replace(/:AWAIT:/g, isAwait ? "await " : "").replace(/(,\s*)?:LAST:/g, isChained ? "$1injection_return" : "");
        };
        var getInjections = getInjections2;
        const name = id.slice(setupEntry.length + 1).replace(/\?.*$/, "");
        const imports = [];
        const injections = [];
        const setups = _utils.uniq.call(void 0, [
          ...themeRoots,
          ...addonRoots,
          userRoot
        ]).map((i) => _path.join.call(void 0, i, "setup", name));
        setups.forEach((path, idx) => {
          if (!_fs.existsSync.call(void 0, path))
            return;
          imports.push(`import __n${idx} from '${_chunkCGJOXW6Ijs.toAtFS.call(void 0, path)}'`);
          let fn = `:AWAIT:__n${idx}`;
          if (/\binjection_return\b/g.test(code))
            fn = `injection_return = ${fn}`;
          if (/\binjection_arg\b/g.test(code)) {
            fn += "(";
            const matches = Array.from(code.matchAll(/\binjection_arg(_\d+)?\b/g));
            const dedupedMatches = Array.from(new Set(matches.map((m) => m[0])));
            fn += dedupedMatches.join(", ");
            fn += ", :LAST:)";
          } else {
            fn += "(:LAST:)";
          }
          injections.push(
            `// ${path}`,
            fn
          );
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", getInjections2());
        code = code.replace("/* __async_injections__ */", getInjections2(true));
        code = code.replace("/* __chained_injections__ */", getInjections2(false, true));
        code = code.replace("/* __chained_async_injections__ */", getInjections2(true, true));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/markdown.ts
var _vite7 = require('unplugin-vue-markdown/vite'); var _vite8 = _interopRequireDefault(_vite7);
var _jsbase64 = require('js-base64'); var base64 = _interopRequireWildcard(_jsbase64);


var _markdownitfootnote = require('markdown-it-footnote'); var _markdownitfootnote2 = _interopRequireDefault(_markdownitfootnote);
var _markdownitplugins = require('@hedgedoc/markdown-it-plugins');
var _plantumlencoder = require('plantuml-encoder');
var _markdownitmdc = require('markdown-it-mdc'); var _markdownitmdc2 = _interopRequireDefault(_markdownitmdc);

// node/plugins/markdown-it-katex.ts
var _katex = require('katex'); var _katex2 = _interopRequireDefault(_katex);
function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || /* \t */
  nextChar >= 48 && nextChar <= 57)
    can_close = false;
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\")
      pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md2, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return _katex2.default.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${_katex2.default.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md2.inline.ruler.after("escape", "math_inline", math_inline);
  md2.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md2.renderer.rules.math_inline = inlineRenderer;
  md2.renderer.rules.math_block = blockRenderer;
}

// node/plugins/markdown-it-prism.ts
var _prismjs = require('prismjs'); var _prismjs2 = _interopRequireDefault(_prismjs);
var _2 = require('prismjs/components/'); var _3 = _interopRequireDefault(_2);
var _htmlparser2 = require('htmlparser2'); var htmlparser2 = _interopRequireWildcard(_htmlparser2);
var Tag = class {
  constructor(tagname, attributes) {
    this.tagname = tagname;
    this.attributes = attributes;
  }
  asOpen() {
    return `<${this.tagname} ${Object.entries(this.attributes).map(([key, value]) => `${key}="${value}"`).join(" ")}>`;
  }
  asClosed() {
    return `</${this.tagname}>`;
  }
};
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = _prismjs2.default.languages[lang];
  if (langObject === void 0) {
    _3.default.call(void 0, [lang]);
    langObject = _prismjs2.default.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    _chunkYUG22S6Wjs.__require.call(void 0, `prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`);
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  let code = text.trimEnd();
  code = prismLang ? highlightPrism(code, prismLang, langToUse) : markdownit.utils.escapeHtml(code);
  code = code.split(/\r?\n/g).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return escapeVueInCode(`<pre${classAttribute}><code>${code}</code></pre>`);
}
function highlightPrism(code, prismLang, langToUse) {
  const openTags = [];
  const parser2 = new htmlparser2.Parser({
    onopentag(tagname, attributes) {
      openTags.push(new Tag(tagname, attributes));
    },
    onclosetag() {
      openTags.pop();
    }
  });
  code = _prismjs2.default.highlight(code, prismLang, langToUse);
  code = code.split(/\r?\n/g).map((line) => {
    const prefix = openTags.map((tag) => tag.asOpen()).join("");
    parser2.write(line);
    const postfix = openTags.reverse().map((tag) => tag.asClosed()).join("");
    return prefix + line + postfix;
  }).join("\n");
  parser2.end();
  return code;
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function markdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(_prismjs2.default);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}

// node/plugins/markdown-it-shiki.ts
function getThemeName(theme) {
  if (typeof theme === "string")
    return theme;
  return theme.name;
}
function isShikiDarkModeThemes(theme) {
  return typeof theme === "object" && ("dark" in theme || "light" in theme);
}
function resolveShikiOptions(options) {
  const themes = [];
  let darkModeThemes;
  if (!options.theme) {
    themes.push("nord");
  } else if (typeof options.theme === "string") {
    themes.push(options.theme);
  } else {
    if (isShikiDarkModeThemes(options.theme)) {
      darkModeThemes = options.theme;
      themes.push(options.theme.dark);
      themes.push(options.theme.light);
    } else {
      themes.push(options.theme);
    }
  }
  return {
    ...options,
    themes,
    darkModeThemes: darkModeThemes ? {
      dark: getThemeName(darkModeThemes.dark),
      light: getThemeName(darkModeThemes.light)
    } : void 0
  };
}
function trimEndNewLine(code) {
  return code.replace(/\n$/, "");
}
var MarkdownItShiki = (markdownit, options = {}) => {
  const _highlighter = options.highlighter;
  const { darkModeThemes } = resolveShikiOptions(options);
  markdownit.options.highlight = (code, lang) => {
    if (darkModeThemes) {
      const trimmed = trimEndNewLine(code);
      const dark = _highlighter.codeToHtml(trimmed, { lang: lang || "text", theme: darkModeThemes.dark }).replace('<pre class="shiki', '<pre class="slidev-code shiki shiki-dark');
      const light = _highlighter.codeToHtml(trimmed, { lang: lang || "text", theme: darkModeThemes.light }).replace('<pre class="shiki', '<pre class="slidev-code shiki shiki-light');
      return escapeVueInCode(`<pre class="shiki-container">${dark}${light}</pre>`);
    } else {
      return escapeVueInCode(
        _highlighter.codeToHtml(code, { lang: lang || "text" }).replace('<pre class="shiki"', '<pre class="slidev-code shiki"')
      );
    }
  };
};
var markdown_it_shiki_default = MarkdownItShiki;

// node/plugins/markdown.ts
var DEFAULT_SHIKI_OPTIONS = {
  theme: {
    dark: "min-dark",
    light: "min-light"
  }
};
async function createMarkdownPlugin({ data: { config }, roots, mode, entry }, { markdown: mdOptions }) {
  const setups = [];
  const entryPath = _utils.slash.call(void 0, entry);
  if (config.highlighter === "shiki") {
    const Shiki = await Promise.resolve().then(() => require("shiki"));
    const shikiOptions = await _chunkUWTQKD35js.loadSetups.call(void 0, roots, "shiki.ts", Shiki, DEFAULT_SHIKI_OPTIONS, false);
    const { langs, themes } = resolveShikiOptions(shikiOptions);
    shikiOptions.highlighter = await Shiki.getHighlighter({ themes, langs });
    setups.push((md2) => md2.use(markdown_it_shiki_default, shikiOptions));
  } else {
    setups.push((md2) => md2.use(markdownItPrism));
  }
  if (config.mdc)
    setups.push((md2) => md2.use(_markdownitmdc2.default));
  const KatexOptions = await _chunkUWTQKD35js.loadSetups.call(void 0, roots, "katex.ts", {}, { strict: false }, false);
  return _vite8.default.call(void 0, {
    include: [/\.md$/],
    wrapperClasses: "",
    headEnabled: false,
    frontmatter: false,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true,
      ..._optionalChain([mdOptions, 'optionalAccess', _52 => _52.markdownItOptions])
    },
    ...mdOptions,
    markdownItSetup(md2) {
      md2.use(_markdownitlinkattributes2.default, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
      md2.use(_markdownitfootnote2.default);
      md2.use(_markdownitplugins.taskLists, { enabled: true, lineNumber: true, label: true });
      md2.use(math_plugin, KatexOptions);
      setups.forEach((i) => i(md2));
      _optionalChain([mdOptions, 'optionalAccess', _53 => _53.markdownItSetup, 'optionalCall', _54 => _54(md2)]);
    },
    transforms: {
      before(code, id) {
        if (id === entryPath)
          return "";
        const monaco = config.monaco === true || config.monaco === mode ? transformMarkdownMonaco : truncateMancoMark;
        code = transformSlotSugar(code);
        code = transformMermaid(code);
        code = transformPlantUml(code, config.plantUmlServer);
        code = monaco(code);
        code = transformHighlighter(code);
        code = transformPageCSS(code, id);
        code = transformKaTex(code);
        return code;
      }
    }
  });
}
function transformKaTex(md2) {
  return md2.replace(/^\$\$(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?)?\n([\s\S]+?)^\$\$/mg, (full, rangeStr = "", _, code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    code = code.trimEnd();
    return `<KaTexBlockWrapper :ranges='${JSON.stringify(ranges)}'>

$$
${code}
$$
</KaTexBlockWrapper>
`;
  });
}
function transformMarkdownMonaco(md2) {
  md2 = md2.replace(/^```(\w+?)\s*{monaco-diff}\s*?({.*?})?\s*?\n([\s\S]+?)^~~~\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code, diff) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    const encodedDiff = base64.encode(diff, true);
    return `<Monaco :code="'${encoded}'" :diff="'${encodedDiff}'" lang="${lang}" v-bind="${options}" />`;
  });
  md2 = md2.replace(/^```(\w+?)\s*{monaco}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Monaco :code="'${encoded}'" lang="${lang}" v-bind="${options}" />`;
  });
  return md2;
}
function truncateMancoMark(md2) {
  return md2.replace(/{monaco.*?}/g, "");
}
function transformSlotSugar(md2) {
  const lines = md2.split(/\r?\n/g);
  let prevSlot = false;
  const { isLineInsideCodeblocks } = getCodeBlocks(md2);
  lines.forEach((line, idx) => {
    if (isLineInsideCodeblocks(idx))
      return;
    const match = line.trimEnd().match(/^::\s*(\w+)\s*::$/);
    if (match) {
      lines[idx] = `${prevSlot ? "\n\n</template>\n" : "\n"}<template v-slot:${match[1]}="slotProps">
`;
      prevSlot = true;
    }
  });
  if (prevSlot)
    lines[lines.length - 1] += "\n\n</template>";
  return lines.join("\n");
}
function transformHighlighter(md2) {
  return md2.replace(/^```(\w+?)(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?)?\n([\s\S]+?)^```/mg, (full, lang = "", rangeStr = "", options = "", code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    code = code.trimEnd();
    options = options.trim() || "{}";
    return `
<CodeBlockWrapper v-bind="${options}" :ranges='${JSON.stringify(ranges)}'>

\`\`\`${lang}
${code}
\`\`\`

</CodeBlockWrapper>`;
  });
}
function getCodeBlocks(md2) {
  const codeblocks = Array.from(md2.matchAll(/^```[\s\S]*?^```/mg)).map((m) => {
    const start = m.index;
    const end = m.index + m[0].length;
    const startLine = _optionalChain([md2, 'access', _55 => _55.slice, 'call', _56 => _56(0, start), 'access', _57 => _57.match, 'call', _58 => _58(/\n/g), 'optionalAccess', _59 => _59.length]) || 0;
    const endLine = _optionalChain([md2, 'access', _60 => _60.slice, 'call', _61 => _61(0, end), 'access', _62 => _62.match, 'call', _63 => _63(/\n/g), 'optionalAccess', _64 => _64.length]) || 0;
    return [start, end, startLine, endLine];
  });
  return {
    codeblocks,
    isInsideCodeblocks(idx) {
      return codeblocks.some(([s, e]) => s <= idx && idx <= e);
    },
    isLineInsideCodeblocks(line) {
      return codeblocks.some(([, , s, e]) => s <= line && line <= e);
    }
  };
}
function transformPageCSS(md2, id) {
  const page = _optionalChain([id, 'access', _65 => _65.match, 'call', _66 => _66(/(\d+)\.md$/), 'optionalAccess', _67 => _67[1]]);
  if (!page)
    return md2;
  const { isInsideCodeblocks } = getCodeBlocks(md2);
  const result = md2.replace(
    /(\n<style[^>]*?>)([\s\S]+?)(<\/style>)/g,
    (full, start, css, end, index) => {
      if (index < 0 || isInsideCodeblocks(index))
        return full;
      if (!start.includes("scoped"))
        start = start.replace("<style", "<style scoped");
      return `${start}
${css}${end}`;
    }
  );
  return result;
}
function transformMermaid(md2) {
  return md2.replace(/^```mermaid\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Mermaid :code="'${encoded}'" v-bind="${options}" />`;
  });
}
function transformPlantUml(md2, server) {
  return md2.replace(/^```plantuml\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", content = "") => {
    const code = _plantumlencoder.encode.call(void 0, content.trim());
    options = options.trim() || "{}";
    return `<PlantUml :code="'${code}'" :server="'${server}'" v-bind="${options}" />`;
  });
}
function escapeVueInCode(md2) {
  return md2.replace(/{{(.*?)}}/g, "&lbrace;&lbrace;$1&rbrace;&rbrace;");
}

// node/plugins/patchTransform.ts

function createFixPlugins(options) {
  const define = _utils.objectEntries.call(void 0, getDefine(options));
  return [
    {
      name: "slidev:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.match(/\.vue($|\?)/)) {
          const original = code;
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          if (original !== code)
            return code;
        }
      }
    }
  ];
}

// node/plugins/preset.ts
var customElements = /* @__PURE__ */ new Set([
  // katex
  "annotation",
  "math",
  "menclose",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
]);
async function ViteSlidevPlugin(options, pluginOptions, serverOptions = {}) {
  const {
    vue: vueOptions = {},
    vuejsx: vuejsxOptions = {},
    components: componentsOptions = {},
    icons: iconsOptions = {},
    remoteAssets: remoteAssetsOptions = {},
    serverRef: serverRefOptions = {}
  } = pluginOptions;
  const {
    mode,
    themeRoots,
    addonRoots,
    clientRoot,
    data: { config }
  } = options;
  const VuePlugin = _pluginvue2.default.call(void 0, {
    include: [/\.vue$/, /\.md$/],
    exclude: [],
    template: {
      compilerOptions: {
        isCustomElement(tag) {
          return customElements.has(tag);
        }
      },
      ..._optionalChain([vueOptions, 'optionalAccess', _68 => _68.template])
    },
    ...vueOptions
  });
  const VueJsxPlugin = _pluginvuejsx2.default.call(void 0, vuejsxOptions);
  const MarkdownPlugin = await createMarkdownPlugin(options, pluginOptions);
  const drawingData = await loadDrawings(options);
  const publicRoots = themeRoots.map((i) => _path.join.call(void 0, i, "public")).filter(_fs.existsSync);
  const plugins = [
    MarkdownPlugin,
    VueJsxPlugin,
    VuePlugin,
    createSlidesLoader(options, pluginOptions, serverOptions),
    _vite6.default.call(void 0, {
      extensions: ["vue", "md", "js", "ts", "jsx", "tsx"],
      dirs: [
        _path.join.call(void 0, clientRoot, "builtin"),
        _path.join.call(void 0, clientRoot, "components"),
        ...themeRoots.map((i) => _path.join.call(void 0, i, "components")),
        ...addonRoots.map((i) => _path.join.call(void 0, i, "components")),
        "src/components",
        "components"
      ],
      include: [/\.vue$/, /\.vue\?vue/, /\.vue\?v=/, /\.md$/],
      exclude: [],
      resolvers: [
        _resolver2.default.call(void 0, {
          prefix: "",
          customCollections: Object.keys(iconsOptions.customCollections || [])
        })
      ],
      dts: false,
      ...componentsOptions
    }),
    _vite4.default.call(void 0, {
      defaultClass: "slidev-icon",
      autoInstall: true,
      ...iconsOptions
    }),
    config.remoteAssets === true || config.remoteAssets === mode ? Promise.resolve().then(() => require("vite-plugin-remote-assets")).then((r) => r.default({
      rules: [
        ...r.DefaultRules,
        {
          match: /\b(https?:\/\/image.unsplash\.com.*?)(?=[`'")\]])/ig,
          ext: ".png"
        }
      ],
      resolveMode: (id) => id.endsWith("index.html") ? "relative" : "@fs",
      awaitDownload: mode === "build",
      ...remoteAssetsOptions
    })) : null,
    _vitepluginvueserverref2.default.call(void 0, {
      debug: _process2.default.env.NODE_ENV === "development",
      state: {
        sync: false,
        nav: {
          page: 0,
          clicks: 0
        },
        drawings: drawingData,
        ...serverRefOptions.state
      },
      onChanged(key, data, patch, timestamp) {
        serverRefOptions.onChanged && serverRefOptions.onChanged(key, data, patch, timestamp);
        if (!options.data.config.drawings.persist)
          return;
        if (key === "drawings")
          writeDrawings(options, _nullishCoalesce(patch, () => ( data)));
      }
    }),
    createConfigPlugin(options),
    createClientSetupPlugin(options),
    createMonacoTypesLoader(),
    createFixPlugins(options),
    publicRoots.length ? Promise.resolve().then(() => require("vite-plugin-static-copy")).then((r) => r.viteStaticCopy({
      silent: true,
      targets: publicRoots.map((r2) => ({
        src: `${r2}/*`,
        dest: "theme"
      }))
    })) : null,
    options.inspect ? Promise.resolve().then(() => require("vite-plugin-inspect")).then((r) => (r.default || r)({
      dev: true,
      build: true
    })) : null,
    config.css === "none" ? null : config.css === "windicss" ? Promise.resolve().then(() => require("./windicss-G7ISUN5H.js")).then((r) => r.createWindiCSSPlugin(options, pluginOptions)) : Promise.resolve().then(() => require("./unocss-E5M4APXD.js")).then((r) => r.createUnocssPlugin(options, pluginOptions))
  ];
  return (await Promise.all(plugins)).flat().filter(_utils.notNullish);
}






exports.getIndexHtml = getIndexHtml; exports.mergeViteConfigs = mergeViteConfigs; exports.require_fast_deep_equal = require_fast_deep_equal; exports.ViteSlidevPlugin = ViteSlidevPlugin;
