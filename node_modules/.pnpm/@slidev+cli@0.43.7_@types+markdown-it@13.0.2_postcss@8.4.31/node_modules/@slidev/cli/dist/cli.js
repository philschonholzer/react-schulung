"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }










var _chunkIJ6NBA73js = require('./chunk-IJ6NBA73.js');


var _chunkGD5JWUM3js = require('./chunk-GD5JWUM3.js');


var _chunkUWTQKD35js = require('./chunk-UWTQKD35.js');
require('./chunk-CGJOXW6I.js');


var _chunkYUG22S6Wjs = require('./chunk-YUG22S6W.js');

// node/cli.ts
var import_fast_deep_equal = _chunkYUG22S6Wjs.__toESM.call(void 0, _chunkGD5JWUM3js.require_fast_deep_equal.call(void 0, ));
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _os = require('os'); var _os2 = _interopRequireDefault(_os);
var _child_process = require('child_process');
var _readline = require('readline'); var readline = _interopRequireWildcard(_readline);
var _process = require('process'); var _process2 = _interopRequireDefault(_process);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _open = require('open'); var _open2 = _interopRequireDefault(_open);
var _yargs = require('yargs'); var _yargs2 = _interopRequireDefault(_yargs);
var _prompts = require('prompts'); var _prompts2 = _interopRequireDefault(_prompts);
var _kolorist = require('kolorist');
var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault(_isinstalledglobally);
var _parser = require('@slidev/parser');
var _fs = require('@slidev/parser/fs');
var _getportplease = require('get-port-please');
var CONFIG_RESTART_FIELDS = [
  "highlighter",
  "monaco",
  "routerMode",
  "fonts",
  "css",
  "mdc",
  "editor"
];
_fs.injectPreparserExtensionLoader.call(void 0, async (headmatter, filepath) => {
  const addons = _nullishCoalesce(_optionalChain([headmatter, 'optionalAccess', _ => _.addons]), () => ( []));
  const roots = (
    /* uniq */
    [
      _chunkIJ6NBA73js.getUserRoot.call(void 0, {}).userRoot,
      ..._chunkIJ6NBA73js.getAddonRoots.call(void 0, addons, ""),
      _chunkIJ6NBA73js.getClientRoot.call(void 0, )
    ]
  );
  const mergeArrays = (a, b) => a.concat(b);
  return await _chunkUWTQKD35js.loadSetups.call(void 0, roots, "preparser.ts", { filepath, headmatter }, [], mergeArrays);
});
var cli = _yargs2.default.scriptName("slidev").usage("$0 [args]").version(_chunkIJ6NBA73js.version).strict().showHelpOnFail(false).alias("h", "help").alias("v", "version");
cli.command(
  "* [entry]",
  "Start a local server for Slidev",
  (args) => commonOptions(args).option("port", {
    alias: "p",
    type: "number",
    describe: "port"
  }).option("open", {
    alias: "o",
    default: false,
    type: "boolean",
    describe: "open in browser"
  }).option("remote", {
    type: "string",
    describe: "listen public host and enable remote control"
  }).option("tunnel", {
    default: false,
    type: "boolean",
    describe: "open localtunnel to make Slidev available on the internet"
  }).option("log", {
    default: "warn",
    type: "string",
    choices: ["error", "warn", "info", "silent"],
    describe: "log level"
  }).option("inspect", {
    default: false,
    type: "boolean",
    describe: "enable the inspect plugin for debugging"
  }).option("force", {
    alias: "f",
    default: false,
    type: "boolean",
    describe: "force the optimizer to ignore the cache and re-bundle  "
  }).strict().help(),
  async ({ entry, theme, port: userPort, open, log, remote, tunnel, force, inspect }) => {
    if (!_fsextra2.default.existsSync(entry) && !entry.endsWith(".md"))
      entry = `${entry}.md`;
    if (!_fsextra2.default.existsSync(entry)) {
      const { create } = await _prompts2.default.call(void 0, {
        name: "create",
        type: "confirm",
        initial: "Y",
        message: `Entry file ${_kolorist.yellow.call(void 0, `"${entry}"`)} does not exist, do you want to create it?`
      });
      if (create)
        await _fsextra2.default.copyFile(_path2.default.resolve(__dirname, "../template.md"), entry);
      else
        _process2.default.exit(0);
    }
    let server;
    let port = 3030;
    let lastRemoteUrl;
    async function initServer() {
      if (server)
        await server.close();
      const options = await _chunkIJ6NBA73js.resolveOptions.call(void 0, { entry, remote, theme, inspect }, "dev");
      port = userPort || await findFreePort(3030);
      server = await _chunkIJ6NBA73js.createServer.call(void 0, 
        options,
        {
          server: {
            port,
            strictPort: true,
            open,
            host: remote !== void 0 ? "0.0.0.0" : "localhost",
            force
          },
          logLevel: log
        },
        {
          onDataReload(newData, data) {
            if (!theme && _chunkIJ6NBA73js.resolveThemeName.call(void 0, newData.config.theme) !== _chunkIJ6NBA73js.resolveThemeName.call(void 0, data.config.theme)) {
              console.log(_kolorist.yellow.call(void 0, "\n  restarting on theme change\n"));
              initServer();
            } else if (CONFIG_RESTART_FIELDS.some((i) => !(0, import_fast_deep_equal.default)(newData.config[i], data.config[i]))) {
              console.log(_kolorist.yellow.call(void 0, "\n  restarting on config change\n"));
              initServer();
            }
          }
        }
      );
      await server.listen();
      let tunnelUrl = "";
      if (tunnel) {
        if (remote != null)
          tunnelUrl = await openTunnel(port);
        else
          console.log(_kolorist.yellow.call(void 0, "\n  --remote is required for tunneling, localtunnel is not enabled.\n"));
      }
      lastRemoteUrl = printInfo(options, port, remote, tunnelUrl);
    }
    async function openTunnel(port2) {
      const localtunnel = await Promise.resolve().then(() => require("localtunnel")).then((r) => r.default || r);
      const tunnel2 = await localtunnel({
        port: port2,
        local_host: "0.0.0.0"
      });
      return tunnel2.url;
    }
    const SHORTCUTS = [
      {
        name: "r",
        fullname: "restart",
        action() {
          initServer();
        }
      },
      {
        name: "o",
        fullname: "open",
        action() {
          _open2.default.call(void 0, `http://localhost:${port}`);
        }
      },
      {
        name: "e",
        fullname: "edit",
        action() {
          _child_process.exec.call(void 0, `code "${entry}"`);
        }
      },
      {
        name: "q",
        fullname: "quit",
        action() {
          try {
            _optionalChain([server, 'optionalAccess', _2 => _2.close, 'call', _3 => _3()]);
          } finally {
            _process2.default.exit();
          }
        }
      },
      {
        name: "c",
        fullname: "qrcode",
        async action() {
          if (!lastRemoteUrl)
            return;
          await Promise.resolve().then(() => require("uqr")).then((r) => {
            const code = r.renderUnicodeCompact(lastRemoteUrl);
            console.log(`
${_kolorist.dim.call(void 0, "  QR Code for remote control: ")}
  ${_kolorist.blue.call(void 0, lastRemoteUrl)}
`);
            console.log(code.split("\n").map((i) => `  ${i}`).join("\n"));
          });
        }
      }
    ];
    function bindShortcut() {
      _process2.default.stdin.resume();
      _process2.default.stdin.setEncoding("utf8");
      readline.emitKeypressEvents(_process2.default.stdin);
      if (_process2.default.stdin.isTTY)
        _process2.default.stdin.setRawMode(true);
      _process2.default.stdin.on("keypress", (str, key) => {
        if (key.ctrl && key.name === "c") {
          _process2.default.exit();
        } else {
          const [sh] = SHORTCUTS.filter((item) => item.name === str);
          if (sh) {
            try {
              sh.action();
            } catch (err) {
              console.error(`Failed to execute shortcut ${sh.fullname}`, err);
            }
          }
        }
      });
    }
    initServer();
    bindShortcut();
  }
);
cli.command(
  "build [entry..]",
  "Build hostable SPA",
  (args) => exportOptions(commonOptions(args)).option("watch", {
    alias: "w",
    default: false,
    describe: "build watch"
  }).option("out", {
    alias: "o",
    type: "string",
    default: "dist",
    describe: "output dir"
  }).option("base", {
    type: "string",
    describe: "output base"
  }).option("download", {
    alias: "d",
    type: "boolean",
    describe: "allow download as PDF"
  }).option("inspect", {
    default: false,
    type: "boolean",
    describe: "enable the inspect plugin for debugging"
  }).strict().help(),
  async (args) => {
    const { entry, theme, watch, base, download, out, inspect } = args;
    const { build } = await Promise.resolve().then(() => require("./build-BMXGJSEG.js"));
    for (const entryFile of entry) {
      const options = await _chunkIJ6NBA73js.resolveOptions.call(void 0, { entry: entryFile, theme, inspect }, "build");
      if (download && !options.data.config.download)
        options.data.config.download = download;
      printInfo(options);
      await build(options, {
        base,
        build: {
          watch: watch ? {} : void 0,
          outDir: entry.length === 1 ? out : _path2.default.join(out, _path2.default.basename(entryFile, ".md"))
        }
      }, { ...args, entry: entryFile });
    }
  }
);
cli.command(
  "format [entry..]",
  "Format the markdown file",
  (args) => commonOptions(args).strict().help(),
  async ({ entry }) => {
    for (const entryFile of entry) {
      const data = await _chunkIJ6NBA73js.parser.load(entryFile);
      _chunkIJ6NBA73js.parser.prettify(data);
      await _chunkIJ6NBA73js.parser.save(data);
    }
  }
);
cli.command(
  "theme [subcommand]",
  "Theme related operations",
  (command) => {
    return command.command(
      "eject",
      "Eject current theme into local file system",
      (args) => commonOptions(args).option("dir", {
        type: "string",
        default: "theme"
      }),
      async ({ entry, dir, theme: themeInput }) => {
        const data = await _chunkIJ6NBA73js.parser.load(entry);
        const theme = _chunkIJ6NBA73js.resolveThemeName.call(void 0, themeInput || data.config.theme);
        if (theme === "none") {
          console.error('Cannot eject theme "none"');
          _process2.default.exit(1);
        }
        if (_chunkIJ6NBA73js.isPath.call(void 0, theme)) {
          console.error("Theme is already ejected");
          _process2.default.exit(1);
        }
        const roots = _chunkIJ6NBA73js.getThemeRoots.call(void 0, theme, entry);
        if (!roots.length) {
          console.error(`Could not find theme "${theme}"`);
          _process2.default.exit(1);
        }
        const root = roots[0];
        await _fsextra2.default.copy(root, _path2.default.resolve(dir), {
          filter: (i) => !/node_modules|.git/.test(_path2.default.relative(root, i))
        });
        const dirPath = `./${dir}`;
        data.slides[0].frontmatter.theme = dirPath;
        data.slides[0].raw = null;
        await _chunkIJ6NBA73js.parser.save(data);
        console.log(`Theme "${theme}" ejected successfully to "${dirPath}"`);
      }
    );
  },
  () => {
    cli.showHelp();
    _process2.default.exit(1);
  }
);
cli.command(
  "export [entry..]",
  "Export slides to PDF",
  (args) => exportOptions(commonOptions(args)).strict().help(),
  async (args) => {
    const { entry, theme } = args;
    _process2.default.env.NODE_ENV = "production";
    const { exportSlides, getExportOptions } = await Promise.resolve().then(() => require("./export-EYYLD3O6.js"));
    const port = await findFreePort(12445);
    for (const entryFile of entry) {
      const options = await _chunkIJ6NBA73js.resolveOptions.call(void 0, { entry: entryFile, theme }, "export");
      const server = await _chunkIJ6NBA73js.createServer.call(void 0, 
        options,
        {
          server: { port },
          clearScreen: false
        }
      );
      await server.listen(port);
      printInfo(options);
      _chunkIJ6NBA73js.parser.filterDisabled(options.data);
      const result = await exportSlides({
        port,
        ...getExportOptions({ ...args, entry: entryFile }, options)
      });
      console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${result}
`);
      server.close();
    }
    _process2.default.exit(0);
  }
);
cli.command(
  "export-notes [entry..]",
  "Export slide notes to PDF",
  (args) => args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("output", {
    type: "string",
    describe: "path to the output"
  }).option("timeout", {
    default: 3e4,
    type: "number",
    describe: "timeout for rendering the print page"
  }).strict().help(),
  async ({
    entry,
    output,
    timeout
  }) => {
    _process2.default.env.NODE_ENV = "production";
    const { exportNotes } = await Promise.resolve().then(() => require("./export-EYYLD3O6.js"));
    const port = await findFreePort(12445);
    for (const entryFile of entry) {
      const options = await _chunkIJ6NBA73js.resolveOptions.call(void 0, { entry: entryFile }, "export");
      const server = await _chunkIJ6NBA73js.createServer.call(void 0, 
        options,
        {
          server: { port },
          clearScreen: false
        }
      );
      await server.listen(port);
      printInfo(options);
      _chunkIJ6NBA73js.parser.filterDisabled(options.data);
      const result = await exportNotes({
        port,
        output: output || (options.data.config.exportFilename ? `${options.data.config.exportFilename}-notes` : `${_path2.default.basename(entryFile, ".md")}-export-notes`),
        timeout
      });
      console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${result}
`);
      server.close();
    }
    _process2.default.exit(0);
  }
);
cli.help().parse();
function commonOptions(args) {
  return args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("theme", {
    alias: "t",
    type: "string",
    describe: "override theme"
  });
}
function exportOptions(args) {
  return args.option("output", {
    type: "string",
    describe: "path to the output"
  }).option("format", {
    type: "string",
    choices: ["pdf", "png", "md"],
    describe: "output format"
  }).option("timeout", {
    type: "number",
    describe: "timeout for rendering the print page"
  }).option("range", {
    type: "string",
    describe: 'page ranges to export, for example "1,4-5,6"'
  }).option("dark", {
    type: "boolean",
    describe: "export as dark theme"
  }).option("with-clicks", {
    alias: "c",
    type: "boolean",
    describe: "export pages for every clicks"
  }).option("executable-path", {
    type: "string",
    describe: "executable to override playwright bundled browser"
  }).option("with-toc", {
    type: "boolean",
    describe: "export pages with outline"
  }).option("per-slide", {
    type: "boolean",
    describe: "slide slides slide by slide. Works better with global components, but will break cross slide links and TOC in PDF"
  });
}
function printInfo(options, port, remote, tunnelUrl) {
  console.log();
  console.log();
  console.log(`  ${_kolorist.cyan.call(void 0, "\u25CF") + _kolorist.blue.call(void 0, "\u25A0") + _kolorist.yellow.call(void 0, "\u25B2")}`);
  console.log(`${_kolorist.bold.call(void 0, "  Slidev")}  ${_kolorist.blue.call(void 0, `v${_chunkIJ6NBA73js.version}`)} ${_isinstalledglobally2.default ? _kolorist.yellow.call(void 0, "(global)") : ""}`);
  console.log();
  _parser.verifyConfig.call(void 0, options.data.config, options.data.themeMeta, (v) => console.warn(_kolorist.yellow.call(void 0, `  ! ${v}`)));
  console.log(_kolorist.dim.call(void 0, "  theme       ") + (options.theme ? _kolorist.green.call(void 0, options.theme) : _kolorist.gray.call(void 0, "none")));
  console.log(_kolorist.dim.call(void 0, "  css engine  ") + (options.data.config.css ? _kolorist.blue.call(void 0, options.data.config.css) : _kolorist.gray.call(void 0, "none")));
  console.log(_kolorist.dim.call(void 0, "  entry       ") + _kolorist.dim.call(void 0, _path2.default.dirname(options.entry) + _path2.default.sep) + _path2.default.basename(options.entry));
  if (port) {
    const query = remote ? `?password=${remote}` : "";
    const presenterPath = `${options.data.config.routerMode === "hash" ? "/#/" : "/"}presenter/${query}`;
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  public slide show ")}  > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/`)}`);
    if (query)
      console.log(`${_kolorist.dim.call(void 0, "  private slide show ")} > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/${query}`)}`);
    console.log(`${_kolorist.dim.call(void 0, "  presenter mode ")}     > ${_kolorist.blue.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}${presenterPath}`)}`);
    if (options.inspect)
      console.log(`${_kolorist.dim.call(void 0, "  inspector")}           > ${_kolorist.yellow.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/__inspect/`)}`);
    let lastRemoteUrl = "";
    if (remote !== void 0) {
      Object.values(_os2.default.networkInterfaces()).forEach((v) => (v || []).filter((details) => String(details.family).slice(-1) === "4" && !details.address.includes("127.0.0.1")).forEach(({ address }) => {
        lastRemoteUrl = `http://${address}:${port}${presenterPath}`;
        console.log(`${_kolorist.dim.call(void 0, "  remote control ")}     > ${_kolorist.blue.call(void 0, lastRemoteUrl)}`);
      }));
      if (tunnelUrl) {
        lastRemoteUrl = `${tunnelUrl}${presenterPath}`;
        console.log(`${_kolorist.dim.call(void 0, "  remote via tunnel")}   > ${_kolorist.yellow.call(void 0, lastRemoteUrl)}`);
      }
    } else {
      console.log(`${_kolorist.dim.call(void 0, "  remote control ")}     > ${_kolorist.dim.call(void 0, "pass --remote to enable")}`);
    }
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  shortcuts ")}          > ${_kolorist.underline.call(void 0, "r")}${_kolorist.dim.call(void 0, "estart | ")}${_kolorist.underline.call(void 0, "o")}${_kolorist.dim.call(void 0, "pen | ")}${_kolorist.underline.call(void 0, "e")}${_kolorist.dim.call(void 0, "dit | ")}${_kolorist.underline.call(void 0, "q")}${_kolorist.dim.call(void 0, "uit")}${lastRemoteUrl ? ` | ${_kolorist.dim.call(void 0, "qr")}${_kolorist.underline.call(void 0, "c")}${_kolorist.dim.call(void 0, "ode")}` : ""}`);
    return lastRemoteUrl;
  }
}
async function findFreePort(start) {
  if (await _getportplease.checkPort.call(void 0, start) !== false)
    return start;
  return findFreePort(start + 1);
}
