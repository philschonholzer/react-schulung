"use strict";Object.defineProperty(exports, "__esModule", {value: true}); async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
















var _chunkHBQPSWBSjs = require('./chunk-HBQPSWBS.js');

// src/fs.ts
var _fs = require('fs');
var _path = require('path');
var preparserExtensionLoader = null;
function injectPreparserExtensionLoader(fn) {
  preparserExtensionLoader = fn;
}
async function load(filepath, themeMeta, content) {
  const dir = _path.dirname.call(void 0, filepath);
  const markdown = await _asyncNullishCoalesce(content, async () => ( await _fs.promises.readFile(filepath, "utf-8")));
  const preparserExtensions = [];
  const data = await _chunkHBQPSWBSjs.parse.call(void 0, markdown, filepath, themeMeta, [], async (headmatter, exts, filepath2) => {
    preparserExtensions.splice(
      0,
      preparserExtensions.length,
      ...exts,
      ...preparserExtensionLoader ? await preparserExtensionLoader(headmatter, filepath2) : []
    );
    return preparserExtensions;
  });
  const entries = /* @__PURE__ */ new Set([
    filepath
  ]);
  for (let iSlide = 0; iSlide < data.slides.length; ) {
    const baseSlide = data.slides[iSlide];
    if (!baseSlide.frontmatter.src) {
      iSlide++;
      continue;
    }
    data.slides.splice(iSlide, 1);
    if (baseSlide.frontmatter.hide)
      continue;
    const srcExpression = baseSlide.frontmatter.src;
    let path;
    if (srcExpression.startsWith("/"))
      path = _path.resolve.call(void 0, dir, srcExpression.substring(1));
    else if (_optionalChain([baseSlide, 'access', _ => _.source, 'optionalAccess', _2 => _2.filepath]))
      path = _path.resolve.call(void 0, _path.dirname.call(void 0, baseSlide.source.filepath), srcExpression);
    else
      path = _path.resolve.call(void 0, dir, srcExpression);
    const raw = await _fs.promises.readFile(path, "utf-8");
    const subSlides = await _chunkHBQPSWBSjs.parse.call(void 0, raw, path, themeMeta, preparserExtensions);
    for (const [offset, subSlide] of subSlides.slides.entries()) {
      const slide = { ...baseSlide };
      slide.source = {
        filepath: path,
        ...subSlide
      };
      if (offset === 0 && !baseSlide.frontmatter.srcSequence) {
        slide.inline = { ...baseSlide };
        delete slide.inline.frontmatter.src;
        Object.assign(slide, slide.source, { raw: null });
      } else {
        Object.assign(slide, slide.source);
      }
      const baseSlideFrontMatterWithoutSrc = { ...baseSlide.frontmatter };
      delete baseSlideFrontMatterWithoutSrc.src;
      slide.frontmatter = {
        ...subSlide.frontmatter,
        ...baseSlideFrontMatterWithoutSrc,
        srcSequence: `${baseSlide.frontmatter.srcSequence ? `${baseSlide.frontmatter.srcSequence},` : ""}${srcExpression}`
      };
      data.features = _chunkHBQPSWBSjs.mergeFeatureFlags.call(void 0, data.features, _chunkHBQPSWBSjs.detectFeatures.call(void 0, raw));
      entries.add(path);
      data.slides.splice(iSlide + offset, 0, slide);
    }
  }
  for (let iSlide = 0; iSlide < data.slides.length; iSlide++)
    data.slides[iSlide].index = iSlide === 0 ? 0 : 1 + data.slides[iSlide - 1].index;
  data.entries = Array.from(entries);
  return data;
}
async function save(data, filepath) {
  filepath = filepath || data.filepath;
  await _fs.promises.writeFile(filepath, _chunkHBQPSWBSjs.stringify.call(void 0, data), "utf-8");
}
async function saveExternalSlide(slide) {
  await _fs.promises.writeFile(slide.filepath, _chunkHBQPSWBSjs.stringifySlide.call(void 0, slide), "utf-8");
}





















exports.detectFeatures = _chunkHBQPSWBSjs.detectFeatures; exports.filterDisabled = _chunkHBQPSWBSjs.filterDisabled; exports.getDefaultConfig = _chunkHBQPSWBSjs.getDefaultConfig; exports.injectPreparserExtensionLoader = injectPreparserExtensionLoader; exports.load = load; exports.mergeFeatureFlags = _chunkHBQPSWBSjs.mergeFeatureFlags; exports.parse = _chunkHBQPSWBSjs.parse; exports.parseAspectRatio = _chunkHBQPSWBSjs.parseAspectRatio; exports.parseRangeString = _chunkHBQPSWBSjs.parseRangeString; exports.parseSlide = _chunkHBQPSWBSjs.parseSlide; exports.prettify = _chunkHBQPSWBSjs.prettify; exports.prettifySlide = _chunkHBQPSWBSjs.prettifySlide; exports.resolveConfig = _chunkHBQPSWBSjs.resolveConfig; exports.resolveFonts = _chunkHBQPSWBSjs.resolveFonts; exports.save = save; exports.saveExternalSlide = saveExternalSlide; exports.scanMonacoModules = _chunkHBQPSWBSjs.scanMonacoModules; exports.stringify = _chunkHBQPSWBSjs.stringify; exports.stringifySlide = _chunkHBQPSWBSjs.stringifySlide; exports.verifyConfig = _chunkHBQPSWBSjs.verifyConfig;
